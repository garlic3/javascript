/* 
    스코프(scope) : 식별자 자신을 참조할수 있는 유효범위
    모든 식별자는 자신이 선언된 위치에 의해 스코프(식별자 자신을 참조할수 있는 유효범위)가 결정된다

    1. var로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용되지만 2번째 선언문이 할당으로 사용되게 된다
    2. 전역 스코프 : 코드의 가장 바깥 영역. 전역변수. 어디서든지 참조 가능
       지역 스코프 : 함수 내부. 지역변수. 자신의 지역 스코프와 하위 지역 스코프에서 유효
    
    스코프 체인 : 스코프가 계층적으로 연결된것
    1. 스코프 체인을 통해 하위 스코프 -> 상위 스코프로 이동하며 변수를 검색한다
    2. 하위 스코프에서 유효한 변수는 상위 스코프에서 참조 불가

*/

// ex13-07
// 함수 레벨 스코프 : var로 선언된 변수는 함수 내부만을 지역 스코프로 인정한다 
var x = 1;
if(true){
    var x = 10; // 전역변수 중복선언
}

/* 
    1. 동적 스코프 : 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정
    2. 렉시컬 스코프 : 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정
*/

// ex13-09
var a = 1;
function foo(){
    var x = 10;
    bar();
}

function bar(){
    console.log(x);
}

foo(); // 1
bar(); // 1. 함수의 상위 스코프는 함수가 정의된곳 

/* 
    변수의 생명 주기 
    메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리풀에 반환되는 시점까지

    1. 전역변수 : 애플리케이션의 생명주기와 동일
    2. 지역변수 : 함수의 생명주기와 동일. 함수 호출시 생성, 함수 종료시 소멸

*/

// ex14-02
// 호이스팅은 스코프 단위로 동작한다
// 변수 선언이 스코프의 선두로 올려진것처럼 동작

var z = 'global';

function foo2(){
    // 호이스팅으로 인해 var z;
    console.log(z); // undifined
    var z = 'local';
}

foo2();
console.log(z); // global

/* 
    전역 객체 : 자바스크립트 엔진에 의해 가장 먼저 생성되는 특수 객체
    클라이언트 사이드 환경(브라우저) : window
    서버 사이드 환경(node.js) : global

    전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, var로 선언한 전역변수와 전역함수를 프로퍼티로 가짐
*/

/* 
    전역변수 
    1. 암묵적 결합 허용(모든 코드가 전역변수를 참조하고 변경할수 있음)
    2. 긴 생명주기 -> 메모리 리소스 소비가 길다
    3. 스코프 체인 상에서 종점에 존재(전역 변수의 검색속도가 가장 느림)
    4. 네임스페이스 오염(파일이 분리되어 있다해도 하나의 전역스코프를 공유)

    -> 변수의 스코프는 좁을수록 좋음

    1. 즉시 실행 함수 사용
    2. 네임스페이스 객체 사용
    3. 모듈 패턴 사용
        캡슐화 : 프로퍼티와 메소드를 하나로 묶는것 -> 정보 은닉

    ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
*/

/* 
    var 사용의 문제점
    1. 변수 중복 선언 허용
    2. 함수 레벨 스코프(함수 코드 블록만 지역 스코프로 인정함)
    3. 변수 호이스팅

    let 키워드
    1. 변수 중복 선언 금지
    2. 블록 레벨 스코프
    3. 변수 호이스팅
        let으로 선언된 변수는 선언단계와 초기화 단계가 분리되어 진행됨
        -> 초기화 단계는 변수 선언문에 도달했을때 실행됨
    4. let 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아님

    const 키워드
    1. const로 선언한 변수는 반드시 선언과 동시에 초기화 해야함
    2. 재할당 금지

*/

// ex15-19
// const로 선언된 변수에 객체를 할당한 경우 값 변경 가능

const person = {
    name : 'seo'
};

person.name = 'min';
console.log(person);

/* 
    1. ES6 사용시 var 키워드 사용 x
    2. 재할당이 필요한 경우에 한정해 let 사용 (단, 변수의 스코프를 최대한 좁게)
    3. 읽기전용, 객체에는 const 키워드 사용
*/

/* 
    내부 슬롯, 내부 메소드 : 의사 프로퍼티, 의사 메소드
    내부 슬롯과 메소드에 직접적으로 접근이나 호출할수 없지만 간접적 수단을 통해서는 가능
  
    프로퍼티 어트리뷰트: 프로퍼티의 상태(프로퍼티의값, 값 갱신여부, 열거 가능여부, 재정의 가능 여부)
    프로퍼티 디스크립터: 프로퍼티 어트리뷰트 정보를 제공하는 객체

    프로퍼티
        1. 데이터 프로퍼티 (키 + 값)
        2. 접근자 프로퍼티 (자체적으로 값을 갖지 안고 접근자 함수로 구성)

    데이터 프로퍼티
        프로퍼티 어트리뷰트 : 프로퍼티 디스크립터 : 설명 
        [[Value]] : value : 값
        [[Writable]] : writable : 변경 가능 여부
        [[Enumerable]] : enumerable : 열거 가능 여부
        [[Configurable]] : configurable : 재정의 가능 여부

    접근자 프로퍼티
        프로퍼티 어트리뷰트 : 프로퍼티 디스크립터 : 설명
        [[Get]] : get : 값을 읽을때
        [[Set]] : set : 값을 저장할때
        [[Enumerable]] : enumerable : 열거
        [[Configurable]] : configurable : 재정의

*/

// ex16-06

const human = {
    firstName : 'min',
    lastName : 'hong',

    get fullName(){
        return `${this.firstName} ${this.lastName}`;
    },

    set fullName(name){
        [this.firstName, this.lastName] = name.split(' ');
    }
};

// setter
person.fullName = 'min kim';
console.log(person);

// getter
console.log(person.fullName);

/* 
    객체 변경 방지
    1. 객체 확장 금지(프로퍼티 추가 금지)
    2. 객체 밀봉(읽기, 쓰기만 가능)
    3. 객체 동결(읽기만 가능)

*/

/* 
    생성자 함수에 의한 객체 생성
    1. Object 생성자 함수
*/

// ex17-01
// Object 생성자 함수

const p = new Object();

p.name = 'min';
p.sayHello = function(){
    console.log('hello');
};

console.log(p);
p.sayHello();

// ex17-04
// 생성자 함수에 의한 객체 생성

function Circle(radius){
    this.radius = radius;
    this.getDiameter = function(){
        return 2 * this.radius;
    };
}

const circle1 = new Circle(5); // new 연산자와 호출하지 않으면 일반함수로 동작
const circle2 = new Circle(3);

/* 
    this 바인딩(식별자와 값 연결)
    1. 일반 함수 : 전역객체
    2. 메소드 : 메소드를 호출한 객체
    3. 생성자 함수 : 생성자가 생성할 인스턴스
*/

